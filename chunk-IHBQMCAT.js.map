{"version":3,"sources":["node_modules/@babylonjs/core/Lights/lightConstants.js","node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js","node_modules/@babylonjs/core/Materials/materialHelper.functions.js","node_modules/@babylonjs/core/Maths/math.functions.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js","node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js","node_modules/@babylonjs/core/Shaders/gpuTransform.vertex.js","node_modules/@babylonjs/core/Shaders/gpuTransform.fragment.js","node_modules/@babylonjs/core/Culling/Helper/transformFeedbackBoundingHelper.js"],"sourcesContent":["/** Defines the cross module constantsused by lights to avoid circular dependencies */\nexport class LightConstants {\n    /**\n     * Sort function to order lights for rendering.\n     * @param a First Light object to compare to second.\n     * @param b Second Light object to compare first.\n     * @returns -1 to reduce's a's index relative to be, 0 for no change, 1 to increase a's index relative to b.\n     */\n    static CompareLightsPriority(a, b) {\n        //shadow-casting lights have priority over non-shadow-casting lights\n        //the renderPriority is a secondary sort criterion\n        if (a.shadowEnabled !== b.shadowEnabled) {\n            return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);\n        }\n        return b.renderPriority - a.renderPriority;\n    }\n}\n/**\n * Falloff Default: light is falling off following the material specification:\n * standard material is using standard falloff whereas pbr material can request special falloff per materials.\n */\nLightConstants.FALLOFF_DEFAULT = 0;\n/**\n * Falloff Physical: light is falling off following the inverse squared distance law.\n */\nLightConstants.FALLOFF_PHYSICAL = 1;\n/**\n * Falloff gltf: light is falling off as described in the gltf moving to PBR document\n * to enhance interoperability with other engines.\n */\nLightConstants.FALLOFF_GLTF = 2;\n/**\n * Falloff Standard: light is falling off like in the standard material\n * to enhance interoperability with other materials.\n */\nLightConstants.FALLOFF_STANDARD = 3;\n//lightmapMode Consts\n/**\n * If every light affecting the material is in this lightmapMode,\n * material.lightmapTexture adds or multiplies\n * (depends on material.useLightmapAsShadowmap)\n * after every other light calculations.\n */\nLightConstants.LIGHTMAP_DEFAULT = 0;\n/**\n * material.lightmapTexture as only diffuse lighting from this light\n * adds only specular lighting from this light\n * adds dynamic shadows\n */\nLightConstants.LIGHTMAP_SPECULAR = 1;\n/**\n * material.lightmapTexture as only lighting\n * no light calculation from this light\n * only adds dynamic shadows from this light\n */\nLightConstants.LIGHTMAP_SHADOWSONLY = 2;\n// Intensity Mode Consts\n/**\n * Each light type uses the default quantity according to its type:\n *      point/spot lights use luminous intensity\n *      directional lights use illuminance\n */\nLightConstants.INTENSITYMODE_AUTOMATIC = 0;\n/**\n * lumen (lm)\n */\nLightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;\n/**\n * candela (lm/sr)\n */\nLightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;\n/**\n * lux (lm/m^2)\n */\nLightConstants.INTENSITYMODE_ILLUMINANCE = 3;\n/**\n * nit (cd/m^2)\n */\nLightConstants.INTENSITYMODE_LUMINANCE = 4;\n// Light types ids const.\n/**\n * Light type const id of the point light.\n */\nLightConstants.LIGHTTYPEID_POINTLIGHT = 0;\n/**\n * Light type const id of the directional light.\n */\nLightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;\n/**\n * Light type const id of the spot light.\n */\nLightConstants.LIGHTTYPEID_SPOTLIGHT = 2;\n/**\n * Light type const id of the hemispheric light.\n */\nLightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;\n","/** @internal */\nexport function addClipPlaneUniforms(uniforms) {\n    if (uniforms.indexOf(\"vClipPlane\") === -1) {\n        uniforms.push(\"vClipPlane\");\n    }\n    if (uniforms.indexOf(\"vClipPlane2\") === -1) {\n        uniforms.push(\"vClipPlane2\");\n    }\n    if (uniforms.indexOf(\"vClipPlane3\") === -1) {\n        uniforms.push(\"vClipPlane3\");\n    }\n    if (uniforms.indexOf(\"vClipPlane4\") === -1) {\n        uniforms.push(\"vClipPlane4\");\n    }\n    if (uniforms.indexOf(\"vClipPlane5\") === -1) {\n        uniforms.push(\"vClipPlane5\");\n    }\n    if (uniforms.indexOf(\"vClipPlane6\") === -1) {\n        uniforms.push(\"vClipPlane6\");\n    }\n}\n/** @internal */\nexport function prepareStringDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\n    if (clipPlane)\n        defines.push(\"#define CLIPPLANE\");\n    if (clipPlane2)\n        defines.push(\"#define CLIPPLANE2\");\n    if (clipPlane3)\n        defines.push(\"#define CLIPPLANE3\");\n    if (clipPlane4)\n        defines.push(\"#define CLIPPLANE4\");\n    if (clipPlane5)\n        defines.push(\"#define CLIPPLANE5\");\n    if (clipPlane6)\n        defines.push(\"#define CLIPPLANE6\");\n}\n/** @internal */\nexport function prepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {\n    let changed = false;\n    const clipPlane = !!(primaryHolder.clipPlane ?? secondaryHolder.clipPlane);\n    const clipPlane2 = !!(primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2);\n    const clipPlane3 = !!(primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3);\n    const clipPlane4 = !!(primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4);\n    const clipPlane5 = !!(primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5);\n    const clipPlane6 = !!(primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6);\n    // Do not factorize this code, it breaks browsers optimizations.\n    if (defines[\"CLIPPLANE\"] !== clipPlane) {\n        defines[\"CLIPPLANE\"] = clipPlane;\n        changed = true;\n    }\n    if (defines[\"CLIPPLANE2\"] !== clipPlane2) {\n        defines[\"CLIPPLANE2\"] = clipPlane2;\n        changed = true;\n    }\n    if (defines[\"CLIPPLANE3\"] !== clipPlane3) {\n        defines[\"CLIPPLANE3\"] = clipPlane3;\n        changed = true;\n    }\n    if (defines[\"CLIPPLANE4\"] !== clipPlane4) {\n        defines[\"CLIPPLANE4\"] = clipPlane4;\n        changed = true;\n    }\n    if (defines[\"CLIPPLANE5\"] !== clipPlane5) {\n        defines[\"CLIPPLANE5\"] = clipPlane5;\n        changed = true;\n    }\n    if (defines[\"CLIPPLANE6\"] !== clipPlane6) {\n        defines[\"CLIPPLANE6\"] = clipPlane6;\n        changed = true;\n    }\n    return changed;\n}\n/** @internal */\nexport function bindClipPlane(effect, primaryHolder, secondaryHolder) {\n    let clipPlane = primaryHolder.clipPlane ?? secondaryHolder.clipPlane;\n    setClipPlane(effect, \"vClipPlane\", clipPlane);\n    clipPlane = primaryHolder.clipPlane2 ?? secondaryHolder.clipPlane2;\n    setClipPlane(effect, \"vClipPlane2\", clipPlane);\n    clipPlane = primaryHolder.clipPlane3 ?? secondaryHolder.clipPlane3;\n    setClipPlane(effect, \"vClipPlane3\", clipPlane);\n    clipPlane = primaryHolder.clipPlane4 ?? secondaryHolder.clipPlane4;\n    setClipPlane(effect, \"vClipPlane4\", clipPlane);\n    clipPlane = primaryHolder.clipPlane5 ?? secondaryHolder.clipPlane5;\n    setClipPlane(effect, \"vClipPlane5\", clipPlane);\n    clipPlane = primaryHolder.clipPlane6 ?? secondaryHolder.clipPlane6;\n    setClipPlane(effect, \"vClipPlane6\", clipPlane);\n}\nfunction setClipPlane(effect, uniformName, clipPlane) {\n    if (clipPlane) {\n        effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);\n    }\n}\n","import { Logger } from \"../Misc/logger.js\";\n\nimport { Color3 } from \"../Maths/math.color.js\";\nimport { EngineStore } from \"../Engines/engineStore.js\";\nimport { LightConstants } from \"../Lights/lightConstants.js\";\nimport { prepareDefinesForClipPlanes } from \"./clipPlaneMaterialHelper.js\";\n// Temps\nconst _TempFogColor = Color3.Black();\nconst _TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };\n/**\n * Binds the logarithmic depth information from the scene to the effect for the given defines.\n * @param defines The generated defines used in the effect\n * @param effect The effect we are binding the data to\n * @param scene The scene we are willing to render with logarithmic scale for\n */\nexport function BindLogDepth(defines, effect, scene) {\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || (defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0)) {\n        const camera = scene.activeCamera;\n        if (camera.mode === 1) {\n            Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n        }\n        effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n    }\n}\n/**\n * Binds the fog information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param linearSpace Defines if the fog effect is applied in linear space\n */\nexport function BindFogParameters(scene, mesh, effect, linearSpace = false) {\n    if (effect && scene.fogEnabled && (!mesh || mesh.applyFog) && scene.fogMode !== 0) {\n        effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);\n        // Convert fog color to linear space if used in a linear space computed shader.\n        if (linearSpace) {\n            scene.fogColor.toLinearSpaceToRef(_TempFogColor, scene.getEngine().useExactSrgbConversions);\n            effect.setColor3(\"vFogColor\", _TempFogColor);\n        }\n        else {\n            effect.setColor3(\"vFogColor\", scene.fogColor);\n        }\n    }\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param influencers The number of influencers\n */\nexport function PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {\n    _TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    PrepareAttributesForMorphTargets(attribs, mesh, _TmpMorphInfluencers);\n}\n/**\n * Prepares the list of attributes required for morph targets according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the morph targets attributes for\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForMorphTargets(attribs, mesh, defines) {\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n    if (influencers > 0 && EngineStore.LastCreatedEngine) {\n        const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n        const manager = mesh.morphTargetManager;\n        if (manager?.isUsingTextureForTargets) {\n            return;\n        }\n        const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n        const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n        const uv = manager && manager.supportsUVs && defines[\"UV1\"];\n        for (let index = 0; index < influencers; index++) {\n            attribs.push(`position` + index);\n            if (normal) {\n                attribs.push(`normal` + index);\n            }\n            if (tangent) {\n                attribs.push(`tangent` + index);\n            }\n            if (uv) {\n                attribs.push(`uv` + \"_\" + index);\n            }\n            if (attribs.length > maxAttributesCount) {\n                Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n            }\n        }\n    }\n}\n/**\n * Add the list of attributes required for instances to the attribs array.\n * @param attribs The current list of supported attribs\n * @param needsPreviousMatrices If the shader needs previous matrices\n */\nexport function PushAttributesForInstances(attribs, needsPreviousMatrices = false) {\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n    if (needsPreviousMatrices) {\n        attribs.push(\"previousWorld0\");\n        attribs.push(\"previousWorld1\");\n        attribs.push(\"previousWorld2\");\n        attribs.push(\"previousWorld3\");\n    }\n}\n/**\n * Binds the morph targets information from the mesh to the effect.\n * @param abstractMesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n */\nexport function BindMorphTargetParameters(abstractMesh, effect) {\n    const manager = abstractMesh.morphTargetManager;\n    if (!abstractMesh || !manager) {\n        return;\n    }\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n}\n/**\n * Binds the scene's uniform buffer to the effect.\n * @param effect defines the effect to bind to the scene uniform buffer\n * @param sceneUbo defines the uniform buffer storing scene data\n */\nexport function BindSceneUniformBuffer(effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n}\n/**\n * Helps preparing the defines values about the UVs in used in the effect.\n * UVs are shared as much as we can across channels in the shaders.\n * @param texture The texture we are preparing the UVs for\n * @param defines The defines to update\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function PrepareDefinesForMergedUV(texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\n        defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n        defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n    }\n    else {\n        defines[key + \"DIRECTUV\"] = 0;\n    }\n}\n/**\n * Binds a texture matrix value to its corresponding uniform\n * @param texture The texture to bind the matrix for\n * @param uniformBuffer The uniform buffer receiving the data\n * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n */\nexport function BindTextureMatrix(texture, uniformBuffer, key) {\n    const matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n}\n/**\n * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare for baked vertex animations\n * @param defines The current Defines of the effect\n */\nexport function PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n    if (enabled) {\n        attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n    }\n}\n// Copies the bones transformation matrices into the target array and returns the target's reference\nfunction _CopyBonesTransformationMatrices(source, target) {\n    target.set(source);\n    return target;\n}\n/**\n * Binds the bones information from the mesh to the effect.\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n */\nexport function BindBonesParameters(mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n        return;\n    }\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n        mesh.computeBonesUsingShaders = false;\n    }\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n        const skeleton = mesh.skeleton;\n        if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n            const boneTexture = skeleton.getTransformMatrixTexture(mesh);\n            effect.setTexture(\"boneSampler\", boneTexture);\n            effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n        }\n        else {\n            const matrices = skeleton.getTransformMatrices(mesh);\n            if (matrices) {\n                effect.setMatrices(\"mBones\", matrices);\n                if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n                    if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n                        prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n                    }\n                    effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n                    _CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n                }\n            }\n        }\n    }\n}\n/**\n * Binds the light information to the effect.\n * @param light The light containing the generator\n * @param effect The effect we are binding the data to\n * @param lightIndex The light index in the effect used to render\n */\nexport function BindLightProperties(light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param light Light to bind\n * @param lightIndex Light index\n * @param scene The scene where the light belongs to\n * @param effect The effect we are binding the data to\n * @param useSpecular Defines if specular is supported\n * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n */\nexport function BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n}\n/**\n * Binds the lights information from the scene to the effect for the given mesh.\n * @param scene The scene the lights belongs to\n * @param mesh The mesh we are binding the information to render\n * @param effect The effect we are binding the data to\n * @param defines The generated defines for the effect\n * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n */\nexport function BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n    for (let i = 0; i < len; i++) {\n        const light = mesh.lightSources[i];\n        BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n    }\n}\n/**\n * Prepares the list of attributes required for bones according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param mesh The mesh to prepare the bones attributes for\n * @param defines The current Defines of the effect\n * @param fallbacks The current effect fallback strategy\n */\nexport function PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n        fallbacks.addCPUSkinningFallback(0, mesh);\n        attribs.push(`matricesIndices`);\n        attribs.push(`matricesWeights`);\n        if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n            attribs.push(`matricesIndicesExtra`);\n            attribs.push(`matricesWeightsExtra`);\n        }\n    }\n}\n/**\n * Check and prepare the list of attributes required for instances according to the effect defines.\n * @param attribs The current list of supported attribs\n * @param defines The current MaterialDefines of the effect\n */\nexport function PrepareAttributesForInstances(attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n        PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n    }\n    if (defines.INSTANCESCOLOR) {\n        attribs.push(`instanceColor`);\n    }\n}\n/**\n * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n * @param defines The defines to update while falling back\n * @param fallbacks The authorized effect fallbacks\n * @param maxSimultaneousLights The maximum number of lights allowed\n * @param rank the current rank of the Effect\n * @returns The newly affected rank\n */\nexport function HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {\n    let lightFallbackRank = 0;\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n        if (!defines[\"LIGHT\" + lightIndex]) {\n            break;\n        }\n        if (lightIndex > 0) {\n            lightFallbackRank = rank + lightIndex;\n            fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n        }\n        if (!defines[\"SHADOWS\"]) {\n            if (defines[\"SHADOW\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n            }\n            if (defines[\"SHADOWPCF\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n            }\n            if (defines[\"SHADOWPCSS\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n            }\n            if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n            }\n            if (defines[\"SHADOWESM\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n            }\n            if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n                fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n            }\n        }\n    }\n    return lightFallbackRank++;\n}\n/**\n * Gets the current status of the fog (should it be enabled?)\n * @param mesh defines the mesh to evaluate for fog support\n * @param scene defines the hosting scene\n * @returns true if fog must be enabled\n */\nexport function GetFogState(mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== 0;\n}\n/**\n * Helper used to prepare the list of defines associated with misc. values for shader compilation\n * @param mesh defines the current mesh\n * @param scene defines the current scene\n * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n * @param pointsCloud defines if point cloud rendering has to be turned on\n * @param fogEnabled defines if fog has to be turned on\n * @param alphaTest defines if alpha testing has to be turned on\n * @param defines defines the current list of defines\n * @param applyDecalAfterDetail Defines if the decal is applied after or before the detail\n */\nexport function PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false) {\n    if (defines._areMiscDirty) {\n        defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n        defines[\"POINTSIZE\"] = pointsCloud;\n        defines[\"FOG\"] = fogEnabled && GetFogState(mesh, scene);\n        defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n        defines[\"ALPHATEST\"] = alphaTest;\n        defines[\"DECAL_AFTER_DETAIL\"] = applyDecalAfterDetail;\n    }\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n * @returns true if normals will be required for the rest of the effect\n */\nexport function PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {\n    if (!defines._areLightsDirty) {\n        return defines._needNormals;\n    }\n    let lightIndex = 0;\n    const state = {\n        needNormals: defines._needNormals,\n        needRebuild: false,\n        lightmapMode: false,\n        shadowEnabled: false,\n        specularEnabled: false,\n    };\n    if (scene.lightsEnabled && !disableLighting) {\n        for (const light of mesh.lightSources) {\n            PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n            lightIndex++;\n            if (lightIndex === maxSimultaneousLights) {\n                break;\n            }\n        }\n    }\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled;\n    // Resetting all other lights if any\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\n        if (defines[\"LIGHT\" + index] !== undefined) {\n            defines[\"LIGHT\" + index] = false;\n            defines[\"HEMILIGHT\" + index] = false;\n            defines[\"POINTLIGHT\" + index] = false;\n            defines[\"DIRLIGHT\" + index] = false;\n            defines[\"SPOTLIGHT\" + index] = false;\n            defines[\"SHADOW\" + index] = false;\n            defines[\"SHADOWCSM\" + index] = false;\n            defines[\"SHADOWCSMDEBUG\" + index] = false;\n            defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n            defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n            defines[\"SHADOWCSMNOBLEND\" + index] = false;\n            defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n            defines[\"SHADOWPCF\" + index] = false;\n            defines[\"SHADOWPCSS\" + index] = false;\n            defines[\"SHADOWPOISSON\" + index] = false;\n            defines[\"SHADOWESM\" + index] = false;\n            defines[\"SHADOWCLOSEESM\" + index] = false;\n            defines[\"SHADOWCUBE\" + index] = false;\n            defines[\"SHADOWLOWQUALITY\" + index] = false;\n            defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n        }\n    }\n    const caps = scene.getEngine().getCaps();\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n        state.needRebuild = true;\n    }\n    defines[\"SHADOWFLOAT\"] =\n        state.shadowEnabled && ((caps.textureFloatRender && caps.textureFloatLinearFiltering) || (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering));\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n    if (state.needRebuild) {\n        defines.rebuild();\n    }\n    return state.needNormals;\n}\n/**\n * Prepares the defines related to the light information passed in parameter\n * @param scene The scene we are intending to draw\n * @param mesh The mesh the effect is compiling for\n * @param light The light the effect is compiling for\n * @param lightIndex The index of the light\n * @param defines The defines to update\n * @param specularSupported Specifies whether specular is supported or not (override lights data)\n * @param state Defines the current state regarding what is needed (normals, etc...)\n * @param state.needNormals\n * @param state.needRebuild\n * @param state.shadowEnabled\n * @param state.specularEnabled\n * @param state.lightmapMode\n */\nexport function PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    state.needNormals = true;\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n        state.needRebuild = true;\n    }\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex);\n    // FallOff.\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n    switch (light.falloffType) {\n        case LightConstants.FALLOFF_GLTF:\n            defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n            break;\n        case LightConstants.FALLOFF_PHYSICAL:\n            defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n            break;\n        case LightConstants.FALLOFF_STANDARD:\n            defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n            break;\n    }\n    // Specular\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n        state.specularEnabled = true;\n    }\n    // Shadows\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n        const shadowGenerator = light.getShadowGenerator(scene.activeCamera) ?? light.getShadowGenerator();\n        if (shadowGenerator) {\n            const shadowMap = shadowGenerator.getShadowMap();\n            if (shadowMap) {\n                if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n                    state.shadowEnabled = true;\n                    shadowGenerator.prepareDefines(defines, lightIndex);\n                }\n            }\n        }\n    }\n    if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {\n        state.lightmapMode = true;\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;\n    }\n    else {\n        defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n        defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n}\n/**\n * Helper used to prepare the list of defines associated with frame values for shader compilation\n * @param scene defines the current scene\n * @param engine defines the current engine\n * @param material defines the material we are compiling the shader for\n * @param defines specifies the list of active defines\n * @param useInstances defines if instances have to be turned on\n * @param useClipPlane defines if clip plane have to be turned on\n * @param useThinInstances defines if thin instances have to be turned on\n */\nexport function PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {\n    let changed = PrepareDefinesForCamera(scene, defines);\n    if (useClipPlane !== false) {\n        changed = prepareDefinesForClipPlanes(material, scene, defines);\n    }\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n        defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n        changed = true;\n    }\n    if (defines[\"INSTANCES\"] !== useInstances) {\n        defines[\"INSTANCES\"] = useInstances;\n        changed = true;\n    }\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n        defines[\"THIN_INSTANCES\"] = useThinInstances;\n        changed = true;\n    }\n    if (changed) {\n        defines.markAsUnprocessed();\n    }\n}\n/**\n * Prepares the defines for bones\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBones(mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n        defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n        const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n        if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n            defines[\"BONETEXTURE\"] = true;\n        }\n        else {\n            defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n            defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n            const prePassRenderer = mesh.getScene().prePassRenderer;\n            if (prePassRenderer && prePassRenderer.enabled) {\n                const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n                defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n            }\n        }\n    }\n    else {\n        defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n        defines[\"BonesPerMesh\"] = 0;\n        if (defines[\"BONETEXTURE\"] !== undefined) {\n            defines[\"BONETEXTURE\"] = false;\n        }\n    }\n}\n/**\n * Prepares the defines for morph targets\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMorphTargets(mesh, defines) {\n    const manager = mesh.morphTargetManager;\n    if (manager) {\n        defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n        defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n        defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n        defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numMaxInfluencers || manager.numInfluencers;\n        defines[\"MORPHTARGETS\"] = defines[\"NUM_MORPH_INFLUENCERS\"] > 0;\n        defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n    }\n    else {\n        defines[\"MORPHTARGETS_UV\"] = false;\n        defines[\"MORPHTARGETS_TANGENT\"] = false;\n        defines[\"MORPHTARGETS_NORMAL\"] = false;\n        defines[\"MORPHTARGETS\"] = false;\n        defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n}\n/**\n * Prepares the defines for baked vertex animation\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForBakedVertexAnimation(mesh, defines) {\n    const manager = mesh.bakedVertexAnimationManager;\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n}\n/**\n * Prepares the defines used in the shader depending on the attributes data available in the mesh\n * @param mesh The mesh containing the geometry data we will draw\n * @param defines The defines to update\n * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n * @param useBones Precise whether bones should be used or not (override mesh info)\n * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n * @returns false if defines are considered not dirty and have not been checked\n */\nexport function PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n        return false;\n    }\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(`normal`);\n    if (defines._needNormals && mesh.isVerticesDataPresent(`tangent`)) {\n        defines[\"TANGENT\"] = true;\n    }\n    for (let i = 1; i <= 6; ++i) {\n        defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\n    }\n    if (useVertexColor) {\n        const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(`color`);\n        defines[\"VERTEXCOLOR\"] = hasVertexColors;\n        defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n    if (mesh.isVerticesDataPresent(`instanceColor`) && (mesh.hasInstances || mesh.hasThinInstances)) {\n        defines[\"INSTANCESCOLOR\"] = true;\n    }\n    if (useBones) {\n        PrepareDefinesForBones(mesh, defines);\n    }\n    if (useMorphTargets) {\n        PrepareDefinesForMorphTargets(mesh, defines);\n    }\n    if (useBakedVertexAnimation) {\n        PrepareDefinesForBakedVertexAnimation(mesh, defines);\n    }\n    return true;\n}\n/**\n * Prepares the defines related to multiview\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n */\nexport function PrepareDefinesForMultiview(scene, defines) {\n    if (scene.activeCamera) {\n        const previousMultiview = defines.MULTIVIEW;\n        defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n        if (defines.MULTIVIEW != previousMultiview) {\n            defines.markAsUnprocessed();\n        }\n    }\n}\n/**\n * Prepares the defines related to order independant transparency\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param needAlphaBlending Determines if the material needs alpha blending\n */\nexport function PrepareDefinesForOIT(scene, defines, needAlphaBlending) {\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n        defines.markAsUnprocessed();\n    }\n}\n/**\n * Prepares the defines related to the prepass\n * @param scene The scene we are intending to draw\n * @param defines The defines to update\n * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n */\nexport function PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {\n    const previousPrePass = defines.PREPASS;\n    if (!defines._arePrePassDirty) {\n        return;\n    }\n    const texturesList = [\n        {\n            type: 1,\n            define: \"PREPASS_POSITION\",\n            index: \"PREPASS_POSITION_INDEX\",\n        },\n        {\n            type: 2,\n            define: \"PREPASS_VELOCITY\",\n            index: \"PREPASS_VELOCITY_INDEX\",\n        },\n        {\n            type: 3,\n            define: \"PREPASS_REFLECTIVITY\",\n            index: \"PREPASS_REFLECTIVITY_INDEX\",\n        },\n        {\n            type: 0,\n            define: \"PREPASS_IRRADIANCE\",\n            index: \"PREPASS_IRRADIANCE_INDEX\",\n        },\n        {\n            type: 7,\n            define: \"PREPASS_ALBEDO_SQRT\",\n            index: \"PREPASS_ALBEDO_SQRT_INDEX\",\n        },\n        {\n            type: 5,\n            define: \"PREPASS_DEPTH\",\n            index: \"PREPASS_DEPTH_INDEX\",\n        },\n        {\n            type: 6,\n            define: \"PREPASS_NORMAL\",\n            index: \"PREPASS_NORMAL_INDEX\",\n        },\n    ];\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n        defines.PREPASS = true;\n        defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n        defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;\n        for (let i = 0; i < texturesList.length; i++) {\n            const index = scene.prePassRenderer.getIndex(texturesList[i].type);\n            if (index !== -1) {\n                defines[texturesList[i].define] = true;\n                defines[texturesList[i].index] = index;\n            }\n            else {\n                defines[texturesList[i].define] = false;\n            }\n        }\n    }\n    else {\n        defines.PREPASS = false;\n        for (let i = 0; i < texturesList.length; i++) {\n            defines[texturesList[i].define] = false;\n        }\n    }\n    if (defines.PREPASS != previousPrePass) {\n        defines.markAsUnprocessed();\n        defines.markAsImageProcessingDirty();\n    }\n}\n/**\n * Helper used to prepare the defines relative to the active camera\n * @param scene defines the current scene\n * @param defines specifies the list of active defines\n * @returns true if the defines have been updated, else false\n */\nexport function PrepareDefinesForCamera(scene, defines) {\n    let changed = false;\n    if (scene.activeCamera) {\n        const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\n        const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\n        const isOrtho = scene.activeCamera.mode === 1 ? 1 : 0;\n        const isPersp = scene.activeCamera.mode === 0 ? 1 : 0;\n        if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\n            defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\n            defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\n            changed = true;\n        }\n    }\n    return changed;\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n * @param lightIndex defines the light index\n * @param uniformsList The uniform list\n * @param samplersList The sampler list\n * @param projectedLightTexture defines if projected texture must be used\n * @param uniformBuffersList defines an optional list of uniform buffers\n * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n */\nexport function PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {\n    if (uniformBuffersList) {\n        uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n    if (updateOnlyBuffersList) {\n        return;\n    }\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowTexture\" + lightIndex);\n    samplersList.push(\"depthTexture\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n    if (projectedLightTexture) {\n        samplersList.push(\"projectionLightTexture\" + lightIndex);\n        uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n}\n/**\n * Prepares the uniforms and samplers list to be used in the effect\n * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n * @param samplersList The sampler list\n * @param defines The defines helping in the list generation\n * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n */\nexport function PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {\n    let uniformsList;\n    let uniformBuffersList = null;\n    if (uniformsListOrOptions.uniformsNames) {\n        const options = uniformsListOrOptions;\n        uniformsList = options.uniformsNames;\n        uniformBuffersList = options.uniformBuffersNames;\n        samplersList = options.samplers;\n        defines = options.defines;\n        maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    }\n    else {\n        uniformsList = uniformsListOrOptions;\n        if (!samplersList) {\n            samplersList = [];\n        }\n    }\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n        if (!defines[\"LIGHT\" + lightIndex]) {\n            break;\n        }\n        PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n        uniformsList.push(\"morphTargetInfluences\");\n        uniformsList.push(\"morphTargetCount\");\n    }\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n        uniformsList.push(\"bakedVertexAnimationSettings\");\n        uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n        uniformsList.push(\"bakedVertexAnimationTime\");\n        samplersList.push(\"bakedVertexAnimationTexture\");\n    }\n}\n","import { __decorate } from \"../tslib.es6.js\";\nimport { Vector3 } from \"./math.vector.js\";\nimport { nativeOverride } from \"../Misc/decorators.js\";\n// This helper class is only here so we can apply the nativeOverride decorator to functions.\nclass MathHelpers {\n    static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {\n        for (let index = indexStart; index < indexStart + indexCount; index++) {\n            const offset = indices[index] * 3;\n            const x = positions[offset];\n            const y = positions[offset + 1];\n            const z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    }\n    static extractMinAndMax(positions, start, count, stride, minimum, maximum) {\n        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {\n            const x = positions[offset];\n            const y = positions[offset + 1];\n            const z = positions[offset + 2];\n            minimum.minimizeInPlaceFromFloats(x, y, z);\n            maximum.maximizeInPlaceFromFloats(x, y, z);\n        }\n    }\n}\n__decorate([\n    nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMaxIndexed\", null);\n__decorate([\n    nativeOverride.filter((...[positions]) => !Array.isArray(positions))\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n], MathHelpers, \"extractMinAndMax\", null);\n/**\n * Extracts minimum and maximum values from a list of indexed positions\n * @param positions defines the positions to use\n * @param indices defines the indices to the positions\n * @param indexStart defines the start index\n * @param indexCount defines the end index\n * @param bias defines bias value to add to the result\n * @returns minimum and maximum values\n */\nexport function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n/**\n * Extracts minimum and maximum values from a list of positions\n * @param positions defines the positions to use\n * @param start defines the start index in the positions array\n * @param count defines the number of positions to handle\n * @param bias defines bias value to add to the result\n * @param stride defines the stride size to use (distance between two positions in the positions array)\n * @returns minimum and maximum values\n */\nexport function extractMinAndMax(positions, start, count, bias = null, stride) {\n    const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n    const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n    if (!stride) {\n        stride = 3;\n    }\n    MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);\n    if (bias) {\n        minimum.x -= minimum.x * bias.x + bias.y;\n        minimum.y -= minimum.y * bias.x + bias.y;\n        minimum.z -= minimum.z * bias.x + bias.y;\n        maximum.x += maximum.x * bias.x + bias.y;\n        maximum.y += maximum.y * bias.x + bias.y;\n        maximum.z += maximum.z * bias.x + bias.y;\n    }\n    return {\n        minimum: minimum,\n        maximum: maximum,\n    };\n}\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesDeclaration\";\nconst shader = `#if NUM_BONE_INFLUENCERS>0\nattribute vec4 matricesIndices;attribute vec4 matricesWeights;\n#if NUM_BONE_INFLUENCERS>4\nattribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;\n#endif\n#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#ifdef BONETEXTURE\nuniform highp sampler2D boneSampler;uniform float boneTextureWidth;\n#else\nuniform mat4 mBones[BonesPerMesh];\n#endif\n#ifdef BONES_VELOCITY_ENABLED\nuniform mat4 mPreviousBones[BonesPerMesh];\n#endif\n#ifdef BONETEXTURE\n#define inline\nmat4 readMatrixFromRawSampler(sampler2D smp,float index)\n{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bakedVertexAnimationDeclaration\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\nuniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;\n#ifdef INSTANCES\nattribute vec4 bakedVertexAnimationSettingsInstanced;\n#endif\n#define inline\nmat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)\n{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimationDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexGlobalDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\nuniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];\n#ifdef MORPHTARGETS_TEXTURE \nuniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform highp sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)\n{ \nfloat y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobalDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexDeclaration\";\nconst shader = `#ifdef MORPHTARGETS\n#ifndef MORPHTARGETS_TEXTURE\nattribute vec3 position{X};\n#ifdef MORPHTARGETS_NORMAL\nattribute vec3 normal{X};\n#endif\n#ifdef MORPHTARGETS_TANGENT\nattribute vec3 tangent{X};\n#endif\n#ifdef MORPHTARGETS_UV\nattribute vec2 uv_{X};\n#endif\n#elif {X}==0\nuniform int morphTargetCount;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexDeclaration = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertexGlobal\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\nfloat vertexID;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertexGlobal = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"morphTargetsVertex\";\nconst shader = `#ifdef MORPHTARGETS\n#ifdef MORPHTARGETS_TEXTURE\n#if {X}==0\nfor (int i=0; i<NUM_MORPH_INFLUENCERS; i++) {if (i>=morphTargetCount) break;vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler(i,vertexID)-position)*morphTargetInfluences[i];vertexID+=1.0;\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(readVector3FromRawSampler(i,vertexID) -normal)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(readVector3FromRawSampler(i,vertexID).xy-uv)*morphTargetInfluences[i];vertexID+=1.0;\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(readVector3FromRawSampler(i,vertexID) -tangent.xyz)*morphTargetInfluences[i];\n#endif\n}\n#endif\n#else\npositionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];\n#ifdef MORPHTARGETS_NORMAL\nnormalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_TANGENT\ntangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];\n#endif\n#ifdef MORPHTARGETS_UV\nuvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];\n#endif\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const morphTargetsVertex = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bonesVertex\";\nconst shader = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE\n#if NUM_BONE_INFLUENCERS>0\nmat4 influence;\n#ifdef BONETEXTURE\ninfluence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];\n#endif\n#else\ninfluence=mBones[int(matricesIndices[0])]*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\ninfluence+=mBones[int(matricesIndices[1])]*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\ninfluence+=mBones[int(matricesIndices[2])]*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\ninfluence+=mBones[int(matricesIndices[3])]*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\ninfluence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\ninfluence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\ninfluence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\ninfluence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];\n#endif\n#endif\nfinalWorld=finalWorld*influence;\n#endif\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bonesVertex = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore.js\";\nconst name = \"bakedVertexAnimation\";\nconst shader = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE\n{\n#ifdef INSTANCES\n#define BVASNAME bakedVertexAnimationSettingsInstanced\n#else\n#define BVASNAME bakedVertexAnimationSettings\n#endif\nfloat VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];\n#if NUM_BONE_INFLUENCERS>1\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];\n#endif\n#if NUM_BONE_INFLUENCERS>2\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];\n#endif\n#if NUM_BONE_INFLUENCERS>3\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];\n#endif\n#if NUM_BONE_INFLUENCERS>4\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];\n#endif\n#if NUM_BONE_INFLUENCERS>5\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];\n#endif\n#if NUM_BONE_INFLUENCERS>6\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];\n#endif\n#if NUM_BONE_INFLUENCERS>7\nVATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];\n#endif\nfinalWorld=finalWorld*VATInfluence;}\n#endif\n`;\n// Sideeffect\nShaderStore.IncludesShadersStore[name] = shader;\n/** @internal */\nexport const bakedVertexAnimation = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nimport \"./ShadersInclude/bonesDeclaration.js\";\nimport \"./ShadersInclude/bakedVertexAnimationDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobalDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexDeclaration.js\";\nimport \"./ShadersInclude/morphTargetsVertexGlobal.js\";\nimport \"./ShadersInclude/morphTargetsVertex.js\";\nimport \"./ShadersInclude/bonesVertex.js\";\nimport \"./ShadersInclude/bakedVertexAnimation.js\";\nconst name = \"gpuTransformVertexShader\";\nconst shader = `attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\nout vec3 outPosition;const mat4 identity=mat4(\nvec4(1.0,0.0,0.0,0.0),\nvec4(0.0,1.0,0.0,0.0),\nvec4(0.0,0.0,1.0,0.0),\nvec4(0.0,0.0,0.0,1.0)\n);void main(void) {vec3 positionUpdated=position;\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\nmat4 finalWorld=identity;\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);outPosition=worldPos.xyz;}`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuTransformVertexShader = { name, shader };\n","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore.js\";\nconst name = \"gpuTransformPixelShader\";\nconst shader = `#version 300 es\nvoid main() {discard;}\n`;\n// Sideeffect\nShaderStore.ShadersStore[name] = shader;\n/** @internal */\nexport const gpuTransformPixelShader = { name, shader };\n","import { VertexBuffer, Buffer } from \"../../Buffers/buffer.js\";\n\nimport { BindBonesParameters, BindMorphTargetParameters, PrepareAttributesForBakedVertexAnimation } from \"../../Materials/materialHelper.functions.js\";\nimport { extractMinAndMax } from \"../../Maths/math.functions.js\";\nimport { Vector3 } from \"../../Maths/math.vector.js\";\nimport \"../../Shaders/gpuTransform.vertex.js\";\nimport \"../../Shaders/gpuTransform.fragment.js\";\n/** @internal */\nexport class TransformFeedbackBoundingHelper {\n    /**\n     * Creates a new TransformFeedbackBoundingHelper\n     * @param engine defines the engine to use\n     */\n    constructor(engine) {\n        this._buffers = {};\n        this._effects = {};\n        this._meshListCounter = 0;\n        this._engine = engine;\n    }\n    /** @internal */\n    processAsync(meshes) {\n        if (!Array.isArray(meshes)) {\n            meshes = [meshes];\n        }\n        this._meshListCounter = 0;\n        this._processMeshList(meshes);\n        return Promise.resolve();\n    }\n    _processMeshList(meshes) {\n        const parallelShaderCompile = this._engine.getCaps().parallelShaderCompile;\n        this._engine.getCaps().parallelShaderCompile = undefined;\n        for (let i = 0; i < meshes.length; ++i) {\n            const mesh = meshes[i];\n            const vertexCount = mesh.getTotalVertices();\n            if (vertexCount === 0 || !mesh.getVertexBuffer || !mesh.getVertexBuffer(VertexBuffer.PositionKind)) {\n                continue;\n            }\n            // Get correct effect\n            let computeEffect;\n            let numInfluencers = 0;\n            const defines = [];\n            let uniforms = [];\n            const attribs = [VertexBuffer.PositionKind];\n            const samplers = [];\n            // Bones\n            if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n                attribs.push(VertexBuffer.MatricesIndicesKind);\n                attribs.push(VertexBuffer.MatricesWeightsKind);\n                if (mesh.numBoneInfluencers > 4) {\n                    attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                    attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n                }\n                const skeleton = mesh.skeleton;\n                defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n                if (skeleton.isUsingTextureForMatrices) {\n                    defines.push(\"#define BONETEXTURE\");\n                    if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\n                        uniforms.push(\"boneTextureWidth\");\n                    }\n                    if (samplers.indexOf(\"boneSampler\") === -1) {\n                        samplers.push(\"boneSampler\");\n                    }\n                }\n                else {\n                    defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n                    if (uniforms.indexOf(\"mBones\") === -1) {\n                        uniforms.push(\"mBones\");\n                    }\n                }\n            }\n            else {\n                defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n            }\n            // Morph\n            const manager = mesh ? mesh.morphTargetManager : null;\n            if (manager) {\n                numInfluencers = manager.numMaxInfluencers || manager.numInfluencers;\n                if (numInfluencers > 0) {\n                    defines.push(\"#define MORPHTARGETS\");\n                }\n                if (manager.isUsingTextureForTargets) {\n                    defines.push(\"#define MORPHTARGETS_TEXTURE\");\n                    if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\n                        uniforms.push(\"morphTargetTextureIndices\");\n                    }\n                    if (samplers.indexOf(\"morphTargets\") === -1) {\n                        samplers.push(\"morphTargets\");\n                    }\n                }\n                defines.push(\"#define NUM_MORPH_INFLUENCERS \" + numInfluencers);\n                for (let index = 0; index < numInfluencers; index++) {\n                    attribs.push(VertexBuffer.PositionKind + index);\n                }\n                if (numInfluencers > 0) {\n                    uniforms = uniforms.slice();\n                    uniforms.push(\"morphTargetInfluences\");\n                    uniforms.push(\"morphTargetCount\");\n                    uniforms.push(\"morphTargetTextureInfo\");\n                    uniforms.push(\"morphTargetTextureIndices\");\n                }\n            }\n            // Baked Vertex Animation\n            const bvaManager = mesh.bakedVertexAnimationManager;\n            if (bvaManager && bvaManager.isEnabled) {\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationSettings\");\n                }\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\n                }\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationTime\");\n                }\n                if (samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\n                    samplers.push(\"bakedVertexAnimationTexture\");\n                }\n                PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);\n            }\n            const join = defines.join(\"\\n\");\n            if (!this._effects[join]) {\n                const computeEffectOptions = {\n                    attributes: attribs,\n                    uniformsNames: uniforms,\n                    uniformBuffersNames: [],\n                    samplers: samplers,\n                    defines: join,\n                    fallbacks: null,\n                    onCompiled: null,\n                    onError: null,\n                    indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\n                    maxSimultaneousLights: 0,\n                    transformFeedbackVaryings: [\"outPosition\"],\n                };\n                computeEffect = this._engine.createEffect(\"gpuTransform\", computeEffectOptions, this._engine);\n                this._effects[join] = computeEffect;\n            }\n            else {\n                computeEffect = this._effects[join];\n            }\n            this._compute(mesh, computeEffect);\n        }\n        this._engine.getCaps().parallelShaderCompile = parallelShaderCompile;\n    }\n    _compute(mesh, effect) {\n        const engine = this._engine;\n        // Buffer\n        let targetBuffer;\n        const vertexCount = mesh.getTotalVertices();\n        if (!this._buffers[mesh.uniqueId]) {\n            const targetData = new Float32Array(vertexCount * 3);\n            targetBuffer = new Buffer(mesh.getEngine(), targetData, true, 3);\n            this._buffers[mesh.uniqueId] = targetBuffer;\n        }\n        else {\n            targetBuffer = this._buffers[mesh.uniqueId];\n        }\n        // Bind\n        effect.getEngine().enableEffect(effect);\n        mesh._bindDirect(effect, null, true);\n        // Bones\n        BindBonesParameters(mesh, effect);\n        // Morph targets\n        const manager = mesh.morphTargetManager;\n        if (manager && manager.numInfluencers > 0) {\n            BindMorphTargetParameters(mesh, effect);\n        }\n        // BVA\n        const bvaManager = mesh.bakedVertexAnimationManager;\n        if (bvaManager && bvaManager.isEnabled) {\n            mesh.bakedVertexAnimationManager?.bind(effect, false);\n        }\n        // Update\n        const arrayBuffer = targetBuffer.getData();\n        engine.bindTransformFeedbackBuffer(targetBuffer.getBuffer());\n        engine.setRasterizerState(false);\n        engine.beginTransformFeedback(true);\n        engine.drawArraysType(2, 0, vertexCount);\n        engine.endTransformFeedback();\n        engine.setRasterizerState(true);\n        engine.readTransformFeedbackBuffer(arrayBuffer);\n        engine.bindTransformFeedbackBuffer(null);\n        // Update mesh\n        if (this._meshListCounter === 0) {\n            mesh._refreshBoundingInfo(arrayBuffer, null);\n        }\n        else {\n            const bb = mesh.getBoundingInfo().boundingBox;\n            const extend = extractMinAndMax(arrayBuffer, 0, vertexCount);\n            TransformFeedbackBoundingHelper._Min.copyFrom(bb.minimum).minimizeInPlace(extend.minimum);\n            TransformFeedbackBoundingHelper._Max.copyFrom(bb.maximum).maximizeInPlace(extend.maximum);\n            mesh._refreshBoundingInfoDirect({ minimum: TransformFeedbackBoundingHelper._Min, maximum: TransformFeedbackBoundingHelper._Max });\n        }\n    }\n    /** @internal */\n    registerMeshListAsync(meshes) {\n        if (!Array.isArray(meshes)) {\n            meshes = [meshes];\n        }\n        this._meshList = meshes;\n        this._meshListCounter = 0;\n        return Promise.resolve();\n    }\n    /** @internal */\n    processMeshList() {\n        if (this._meshList.length === 0) {\n            return;\n        }\n        this._processMeshList(this._meshList);\n        this._meshListCounter++;\n    }\n    /** @internal */\n    fetchResultsForMeshListAsync() {\n        this._meshListCounter = 0;\n        return Promise.resolve();\n    }\n    /** @internal */\n    dispose() {\n        for (const key in this._buffers) {\n            this._buffers[key].dispose();\n        }\n        this._buffers = {};\n        this._effects = {};\n        this._engine = null;\n    }\n}\nTransformFeedbackBoundingHelper._Min = new Vector3();\nTransformFeedbackBoundingHelper._Max = new Vector3();\n"],"mappings":"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","names":["name","shader","name","shader","name","shader","name","shader","name","shader","name","shader","name","shader","name","shader","name","shader"],"x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14]}